---
title: "Day032 - 76. Minimum Window Substring "
categories:
  - leetcode_150
toc: true
toc_sticky: true
tock_label: "List"
typora-root-url: ../
---

# [76. Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/)

Given two strings `s` and `t` of lengths `m` and `n` respectively, return *the **minimum window*** 

***substring\***

 *of* `s` *such that every character in* `t` *(**including duplicates**) is included in the window*. If there is no such substring, return *the empty string* `""`.



The testcases will be generated such that the answer is **unique**.

 

**Example 1:**

```
Input: s = "ADOBECODEBANC", t = "ABC"
Output: "BANC"
Explanation: The minimum window substring "BANC" includes 'A', 'B', and 'C' from string t.
```

**Example 2:**

```
Input: s = "a", t = "a"
Output: "a"
Explanation: The entire string s is the minimum window.
```

**Example 3:**

```
Input: s = "a", t = "aa"
Output: ""
Explanation: Both 'a's from t must be included in the window.
Since the largest window of s only has one 'a', return empty string.
```

 

**Constraints:**

- `m == s.length`
- `n == t.length`
- `1 <= m, n <= 105`
- `s` and `t` consist of uppercase and lowercase English letters.

 

**Follow up:** Could you find an algorithm that runs in `O(m + n)` time?

<br>

## **내 풀이** (진행중)

```python
from collections import defaultdict, deque
from copy import deepcopy

class Solution:
    def minWindow(self, s: str, t: str) -> str:
        if s == t: return s
        if len(s) <= len(t): return ""

        """
        l, r 만들어서 오른쪽으로 이동하면서 t가 다 나올때까지 탐색
        다 나오면 길이 저장하고 l이 t에 포함된 다른 단어 하나와 중복될 때 까지 이동
        이동하면 거기서 다시 r을 이동하면서 빠진 글자를 탐색
        반복
        
        s = "ADOBECODEBANC"
        t = "ABC"

        """

        need_count = len(t)
        current_count = 0

        t_dict = {i:1 for i in t}
        s_dict = defaultdict(int)

        l, r = 0, 0
        min_len = len(s)
        answer = []

        while r <= len(s)-1:
            r_str = s[r]
            s_dict[r_str] += 1

            # s_dict에 지금 r pointer가 가르키는 글자를 더해둔 상태.
            if r_str in t_dict and s_dict[r_str] == t_dict[r_str]:
                current_count += 1
                
            if len(s_dict) < len(t):
                r += 1
                continue

            # current_count가 need_count와 같아지면 l을 오른쪽으로 옮기면서 need_count가 1 내려갈 때 까지 이동
            if current_count == need_count and r-l+1 < min_len:
                # print(f"if : {l}, {r}, min_len : {min_len}")
                min_len = r-l+1
                answer = [l, r+1]
                
                while current_count == need_count and l <= len(s) - len(t):
                    l_str = s[l]

                    if l_str in t_dict and s_dict[l_str] == t_dict[l_str]:
                        s_dict[l_str] -= 1
                        current_count -= 1
                        l += 1
                        break
                    else:
                        s_dict[l_str] -= 1
                        l += 1

            r += 1
            
        while l <= len(s) - len(t) and current_count == need_count:
            l_str = s[l]

            if l_str in t_dict and s_dict[l_str] == t_dict[l_str]:
                min_len = r-l+1
                answer = [l, r+1]
                break
                
            else:
                s_dict[l_str] -= 1
                
            l += 1
            
        return s[answer[0]:answer[1]]
```






**\# Time Complexity  : $$O(N)$$** 

<br>

